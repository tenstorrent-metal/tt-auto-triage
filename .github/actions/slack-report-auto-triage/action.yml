name: "Auto Triage Slack Reporter"
description: "Format slack_message.json and send it to Slack."
inputs:
  slack_webhook_url:
    description: "Webhook URL for the Slack channel to be posted to."
    required: true
  slack_message_path:
    description: "Path to slack_message.json."
    required: false
    default: .auto_triage/output/slack_message.json
  job_name:
    description: "The job/subjob name (from user input)."
    required: true
runs:
  using: "composite"
  steps:
    - name: Build Slack payload
      id: build
      shell: bash
      env:
        MESSAGE_PATH: ${{ inputs.slack_message_path }}
      run: |
        set -euo pipefail
        if [ -z "${MESSAGE_PATH:-}" ]; then
          echo "has_payload=false" >> "$GITHUB_OUTPUT"
          exit 0
        fi
        if [ ! -f "$MESSAGE_PATH" ]; then
          echo "Slack message file '$MESSAGE_PATH' not found; skipping notification."
          echo "has_payload=false" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        RUN_URL="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
        RUN_LABEL="run #${GITHUB_RUN_NUMBER:-$GITHUB_RUN_ID}"
        
        # Get job_name input - required but may be empty string from calling workflow
        JOB_NAME_VALUE="${{ inputs.job_name }}"

        TEXT=$(jq -r --arg run_url "$RUN_URL" --arg run_label "$RUN_LABEL" --arg job_name "$JOB_NAME_VALUE" '
          def short_hash(h):
            if (h // "") == "" then "unknown" else (h[0:8]) end;

          def commit_link(c):
            if (c.url // c.commit_url // "") != "" then
              "<" + (c.url // c.commit_url) + "|" + short_hash(c.hash // c.commit) + ">"
            else short_hash(c.hash // c.commit)
            end;

          def person(p; use_slack_id):
            if p == null then
              "Unknown"
            else
              (if use_slack_id and (p.slack_id // "") != "" then
                # Groups/subteams start with "S" and use <!subteam^ID|@handle> format
                (if (p.slack_id | startswith("S")) then
                  "<!subteam^" + p.slack_id + "|@" + (p.name // p.login // "group") + ">"
                else
                  "<@" + p.slack_id + ">"
                end)
              else 
                (p.name // p.login // "Unknown")
              end)
            end;

          def join_people(arr; use_slack_id):
            arr | map(person(.; use_slack_id)) | join(", ");

          def section_line(lbl; txt):
            if (txt // "") != "" then "*\(lbl):* " + txt + "\n" else "" end;

          def section_people(lbl; arr; use_slack_id):
            if (arr | type) == "array" and (arr | length) > 0 then
              "*\(lbl):* " + join_people(arr; use_slack_id) + "\n"
            else "" end;

          def section_files(lbl; arr):
            if (arr | type) == "array" and (arr | length) > 0 then
              "*\(lbl):*\n```\n" + (arr | join("\n")) + "\n```\n"
            else "" end;

          def section_code(lbl; txt):
            if (txt // "") != "" then "*\(lbl):*\n```" + txt + "```\n" else "" end;

          def commit_entry(c):
            "- HASH: " + commit_link(c) + "\n"
            + "  AUTHOR: " + person(c.author; true) + "\n"
            + (if (c.approvers | type) == "array" and (c.approvers | length) > 0 then
                "  APPROVERS: " + join_people(c.approvers; true) + "\n"
              else "" end)
            + (if (c.relevant_developers | type) == "array" and (c.relevant_developers | length) > 0 then
                "  RELEVANT DEVELOPERS: " + join_people(c.relevant_developers; false) + "\n"
              else "" end)
            + (if (c.relevant_files | type) == "array" and (c.relevant_files | length) > 0 then
                "  RELEVANT FILES:\n```\n" + (c.relevant_files | join("\n")) + "\n```\n"
              else "" end);

          def commits_section(arr):
            if (arr | type) == "array" and (arr | length) > 0 then
              "*COMMITS:*\n" + (arr | map(commit_entry(.)) | join("\n")) + "\n"
            else "" end;

          # Determine if commits exist (Case 1 or Case 4)
          (if ((.commits | type) == "array" and (.commits | length) > 0) then true else false end) as $has_commits
          |
          (
            section_line("RUN"; "<\($run_url)|\($run_label)>")
            + section_line("FAILING WORKFLOW"; (.workflow_name // "unknown workflow"))
            + section_line("FAILING JOB"; (if ($job_name // "") != "" then $job_name else (.failing_job_name // .workflow_name // "unknown job") end))
            + section_line("FAILING TEST"; (.failing_test_name // "unknown test"))
            + section_line("FAILING RUN"; (if (.failing_run_url // "") != "" then "<\(.failing_run_url)|\(.failing_run_label // "latest failing run")>" else "" end))
            + section_line("CASE"; .case // "?")
            + section_line("SCENARIO"; .scenario)
            + section_code("FAILURE MESSAGE"; .failure_message)
            + (if (.slack_message // "") != "" then (.slack_message + "\n") else "" end)
            + commits_section(.commits)
            # Only show and ping top-level relevant_developers if there are no commits (Case 2 or Case 3)
            # When commits exist (Case 1 or Case 4), relevant_developers are shown within commit entries (names only, no pings)
            + (if $has_commits then "" else section_people("RELEVANT DEVELOPERS"; .relevant_developers; true) end)
            + section_files("RELEVANT FILES"; .relevant_files)
            + section_line("NOTES"; .notes)
          ) | gsub("\n{3,}"; "\n\n")
        ' "$MESSAGE_PATH")

        if [ -z "$TEXT" ]; then
          echo "Parsed Slack message is empty; skipping notification."
          echo "has_payload=false" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        PAYLOAD=$(jq -cn --arg text "$TEXT" '{text: $text}')
        echo "payload=$PAYLOAD" >> "$GITHUB_OUTPUT"
        echo "has_payload=true" >> "$GITHUB_OUTPUT"

    - name: Report via Slack webhook
      if: steps.build.outputs.has_payload == 'true'
      shell: bash
      env:
        SLACK_WEBHOOK_URL: ${{ inputs.slack_webhook_url }}
        PAYLOAD: ${{ steps.build.outputs.payload }}
      run: |
        set -euo pipefail
        if [ -z "${SLACK_WEBHOOK_URL:-}" ]; then
          echo "Slack webhook URL is not set."
          exit 1
        fi
        curl -s -X POST -H 'Content-type: application/json' --data "$PAYLOAD" "$SLACK_WEBHOOK_URL"

    - name: Skip Slack notification
      if: steps.build.outputs.has_payload != 'true'
      shell: bash
      run: echo "ℹ️ No Slack payload produced; notification skipped."

