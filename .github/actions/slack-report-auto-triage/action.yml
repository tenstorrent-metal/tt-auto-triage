name: "Auto Triage Slack Reporter"
description: "Format slack_message.json and send it to Slack."
inputs:
  slack_webhook_url:
    description: "Webhook URL for the Slack channel to be posted to (deprecated in favor of channel_id + env.SLACK_BOT_TOKEN)."
    required: false
  channel_id:
    description: "Slack Channel ID to post message to."
    required: false
  slack_message_path:
    description: "Path to slack_message.json."
    required: false
    default: .auto_triage/output/slack_message.json
  job_name:
    description: "The job/subjob name (from user input)."
    required: true
  workflow_name:
    description: "The workflow name (from user input)."
    required: true
  auto_fix_meta_path:
    description: "Optional metadata JSON containing auto-fix PR info."
    required: false
    default: ""
  slack_ts:
    description: "Slack message timestamp for threading replies"
    required: false
    default: ""
  allow_pings:
    description: "Whether to allow pinging users/groups in the message."
    required: false
    default: "false"
runs:
  using: "composite"
  steps:
    - name: Build Slack payload
      id: build
      shell: bash
      env:
        MESSAGE_PATH: ${{ inputs.slack_message_path }}
        AUTO_FIX_META: ${{ inputs.auto_fix_meta_path }}
        SLACK_TS: ${{ inputs.slack_ts }}
        ALLOW_PINGS: ${{ inputs.allow_pings }}
      run: |
        set -euo pipefail
        
        # Check for cancellation FIRST
        CANCEL_FILE=".auto_triage/cancel.json"
        if [ -f "$CANCEL_FILE" ]; then
          SHOULD_CANCEL=$(jq -r '.should_cancel // false' "$CANCEL_FILE")
          if [ "$SHOULD_CANCEL" = "true" ]; then
            CANCEL_MESSAGE=$(jq -r '.message // "Auto-triage cancelled"' "$CANCEL_FILE")
            echo "Cancellation detected: $CANCEL_MESSAGE"
            
            # Construct cancellation payload
            if [ -n "$SLACK_TS" ]; then
               PAYLOAD=$(jq -cn --arg msg "Auto-triage cancelled: $CANCEL_MESSAGE" --arg ts "$SLACK_TS" '{text: $msg, thread_ts: $ts}')
            else
               PAYLOAD=$(jq -cn --arg msg "Auto-triage cancelled: $CANCEL_MESSAGE" '{text: $msg}')
            fi
            
            echo "payload=$PAYLOAD" >> "$GITHUB_OUTPUT"
            echo "has_payload=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi
        fi

        if [ -z "${MESSAGE_PATH:-}" ]; then
          echo "has_payload=false" >> "$GITHUB_OUTPUT"
          exit 0
        fi
        if [ ! -f "$MESSAGE_PATH" ]; then
          echo "Slack message file '$MESSAGE_PATH' not found; skipping notification."
          echo "has_payload=false" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        RUN_URL="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
        RUN_LABEL="run #${GITHUB_RUN_NUMBER:-$GITHUB_RUN_ID}"
        
        # Get job_name input - this should always override the LLM's failing_job_name
        JOB_NAME_VALUE="${{ inputs.job_name }}"
        
        # Get workflow_name input - this should always override the LLM's workflow_name
        WORKFLOW_NAME_VALUE="${{ inputs.workflow_name }}"
        
        # Debug: Log the input values (will be visible in workflow logs)
        echo "DEBUG: job_name input value: '${JOB_NAME_VALUE}'"
        echo "DEBUG: job_name input length: ${#JOB_NAME_VALUE}"
        echo "DEBUG: workflow_name input value: '${WORKFLOW_NAME_VALUE}'"
        echo "DEBUG: workflow_name input length: ${#WORKFLOW_NAME_VALUE}"

        # Force the JSON payload to reflect the user-provided job name and workflow name so downstream
        # tooling (and the final Slack message) never rely on the LLM's guess.
        if [ -n "$JOB_NAME_VALUE" ] || [ -n "$WORKFLOW_NAME_VALUE" ]; then
          TMP_JSON=$(mktemp)
          if [ -n "$JOB_NAME_VALUE" ] && [ -n "$WORKFLOW_NAME_VALUE" ]; then
            jq --arg job_name "$JOB_NAME_VALUE" --arg workflow_name "$WORKFLOW_NAME_VALUE" '.failing_job_name = $job_name | .workflow_name = $workflow_name' "$MESSAGE_PATH" > "$TMP_JSON"
          elif [ -n "$JOB_NAME_VALUE" ]; then
            jq --arg job_name "$JOB_NAME_VALUE" '.failing_job_name = $job_name' "$MESSAGE_PATH" > "$TMP_JSON"
          elif [ -n "$WORKFLOW_NAME_VALUE" ]; then
            jq --arg workflow_name "$WORKFLOW_NAME_VALUE" '.workflow_name = $workflow_name' "$MESSAGE_PATH" > "$TMP_JSON"
          fi
          mv "$TMP_JSON" "$MESSAGE_PATH"
        fi

        AUTO_FIX_NOTE=""
        if [ -n "${AUTO_FIX_META:-}" ] && [ -f "$AUTO_FIX_META" ]; then
          AUTO_FIX_NOTE=$(jq -r '.auto_fix_pr_url // ""' "$AUTO_FIX_META" 2>/dev/null || echo "")
        fi

        TEXT=$(jq -r \
          --arg run_url "$RUN_URL" \
          --arg run_label "$RUN_LABEL" \
          --arg job_name "$JOB_NAME_VALUE" \
          --arg workflow_name "$WORKFLOW_NAME_VALUE" \
          --arg auto_fix "$AUTO_FIX_NOTE" \
          --arg allow_pings "$ALLOW_PINGS" '
          def short_hash(h):
            if (h // "") == "" then "unknown" else (h[0:8]) end;

          def commit_link(c):
            if (c.url // c.commit_url // "") != "" then
              "<" + (c.url // c.commit_url) + "|" + short_hash(c.hash // c.commit) + ">"
            else short_hash(c.hash // c.commit)
            end;

          def person(p; use_slack_id):
            if p == null then
              "Unknown"
            else
              # Only ping if allow_pings is true AND use_slack_id is true AND slack_id exists
              (if ($allow_pings == "true") and use_slack_id and (p.slack_id // "") != "" then
                # Groups/subteams start with "S" and use <!subteam^ID|@handle> format
                (if (p.slack_id | startswith("S")) then
                  "<!subteam^" + p.slack_id + "|@" + (p.name // p.login // "group") + ">"
                else
                  "<@" + p.slack_id + ">"
                end)
              else 
                (p.name // p.login // "Unknown")
              end)
            end;

          def join_people(arr; use_slack_id):
            arr | map(person(.; use_slack_id)) | join(", ");

          def ensure_case3_ping(arr; case_val):
            if ((case_val | tostring) == "3") then
              (arr // []) + [{ "name": "metalinfa", "slack_id": "S0985AN7TC5" }]
            else
              (arr // [])
            end;

          def section_line(lbl; txt):
            if (txt // "") != "" then "*\(lbl):* " + txt + "\n" else "" end;

          def section_people(lbl; arr; use_slack_id):
            if (arr | type) == "array" and (arr | length) > 0 then
              "*\(lbl):* " + join_people(arr; use_slack_id) + "\n"
            else "" end;

          def section_files(lbl; arr):
            if (arr | type) == "array" and (arr | length) > 0 then
              "*\(lbl):*\n```\n" + (arr | join("\n")) + "\n```\n"
            else "" end;

          def section_code(lbl; txt):
            if (txt // "") != "" then "*\(lbl):*\n```" + txt + "```\n" else "" end;

          def commit_entry(c):
            "- HASH: " + commit_link(c) + "\n"
            + "  AUTHOR: " + person(c.author; true) + "\n"
            + (if (c.approvers | type) == "array" and (c.approvers | length) > 0 then
                "  APPROVERS: " + join_people(c.approvers; false) + "\n"
              else "" end)
            + (if (c.relevant_developers | type) == "array" and (c.relevant_developers | length) > 0 then
                "  RELEVANT DEVELOPERS: " + join_people(c.relevant_developers; false) + "\n"
              else "" end)
            + (if (c.relevant_files | type) == "array" and (c.relevant_files | length) > 0 then
                "  RELEVANT FILES:\n```\n" + (c.relevant_files | join("\n")) + "\n```\n"
              else "" end);

          def commits_section(arr):
            if (arr | type) == "array" and (arr | length) > 0 then
              "*COMMITS:*\n" + (arr | map(commit_entry(.)) | join("\n")) + "\n"
            else "" end;

          # Determine if commits exist (Case 1 or Case 4)
          (if ((.commits | type) == "array" and (.commits | length) > 0) then true else false end) as $has_commits
          |
          (
            section_line("RUN"; "<\($run_url)|\($run_label)>")
            + section_line("FAILING WORKFLOW"; (if (($workflow_name // "") | length) > 0 then $workflow_name else (.workflow_name // "unknown workflow") end))
            + section_line("FAILING JOB"; (if (($job_name // "") | length) > 0 then $job_name else (.failing_job_name // .workflow_name // "unknown job") end))
            + section_line("FAILING TEST"; (.failing_test_name // "unknown test"))
            + section_line("FAILING RUN"; (if (.failing_run_url // "") != "" then "<\(.failing_run_url)|\(.failing_run_label // "latest failing run")>" else "" end))
            + section_line("SCENARIO"; .scenario)
            + section_code("FAILURE MESSAGE"; .failure_message)
            + (if (.slack_message // "") != "" then (.slack_message + "\n") else "" end)
            + commits_section(.commits)
            # Only show and ping top-level relevant_developers if there are no commits (Case 2 or Case 3)
            # When commits exist (Case 1 or Case 4), relevant_developers are shown within commit entries (names only, no pings)
            + (if $has_commits
               then ""
               else section_people("RELEVANT DEVELOPERS"; ensure_case3_ping(.relevant_developers; .case); true)
              end)
            + section_files("RELEVANT FILES"; .relevant_files)
            + section_line("NOTES"; .notes)
            + (if ($auto_fix // "") != "" then "\n*AUTO-FIX:* Draft PR created -> <\($auto_fix)|link>\n" else "" end)
          ) | gsub("\n{3,}"; "\n\n")
        ' "$MESSAGE_PATH")

        if [ -z "$TEXT" ]; then
          echo "Parsed Slack message is empty; skipping notification."
          echo "has_payload=false" >> "$GITHUB_OUTPUT"
          exit 0
        fi
        
        if [ -n "$SLACK_TS" ]; then
            # If a timestamp is provided, add it to the payload for threading
            PAYLOAD=$(jq -cn --arg text "$TEXT" --arg ts "$SLACK_TS" '{text: $text, thread_ts: $ts}')
        else
            PAYLOAD=$(jq -cn --arg text "$TEXT" '{text: $text}')
        fi

        echo "payload=$PAYLOAD" >> "$GITHUB_OUTPUT"
        echo "has_payload=true" >> "$GITHUB_OUTPUT"

    - name: Report via Slack
      if: steps.build.outputs.has_payload == 'true'
      uses: slackapi/slack-github-action@v1.26.0
      with:
        payload: ${{ steps.build.outputs.payload }}
        channel-id: ${{ inputs.channel_id }}
      env:
        SLACK_BOT_TOKEN: ${{ env.SLACK_BOT_TOKEN }}
        SLACK_WEBHOOK_URL: ${{ inputs.slack_webhook_url }}

    - name: Skip Slack notification
      if: steps.build.outputs.has_payload != 'true'
      shell: bash
      run: echo "ℹ️ No Slack payload produced; notification skipped."
